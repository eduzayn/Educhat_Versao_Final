Sistema de Comunicação Omnichannel com React, Node.js 

I. Introdução e Visão do Sistema

A. Mandato do Projeto

O objetivo central deste projeto é o desenvolvimento de uma plataforma de comunicação Omnichannel moderna, funcional e robusta. A inspiração funcional deriva do sistema Chatwoot, porém, a implementação utilizará um conjunto de tecnologias atuais, escaláveis e com foco em comunicação em tempo real: React com Vite para o frontend, Node.js (preferencialmente com Fastify) para o backend, e PostgreSQL como banco de dados, gerenciado via Supabase (ou Neon, conforme necessidade) e acessado pelo ORM Prisma.

A principal mudança estratégica neste projeto é a substituição do Replit pelo Lovable como ambiente de desenvolvimento, priorizando maior controle sobre a infraestrutura, estabilidade e integração contínua com ferramentas externas como Supabase, Vercel, Litestream, entre outras.

B. Racional da Fundação Tecnológica

A seleção tecnológica foi cuidadosamente definida para atender aos requisitos de modernidade, performance, escalabilidade e ao ambiente de desenvolvimento Lovable:

Frontend (React com Vite): A escolha do React fundamenta-se em seu modelo de componentes reutilizáveis, ecossistema maduro e vasta comunidade, facilitando a construção de interfaces de usuário complexas e interativas. O Vite complementa o React ao oferecer um ambiente de desenvolvimento extremamente rápido, com Hot Module Replacement (HMR) instantâneo e builds otimizadas para produção, resultando em alta performance e uma experiência de desenvolvimento superior. A necessidade de uma interface moderna, fluida e responsiva é um pilar desta escolha, estilizada com TailwindCSS.

Backend (Node.js com Fastify): Node.js é selecionado por sua natureza assíncrona e orientada a eventos, ideal para aplicações de comunicação em tempo real. Dentro do ecossistema Node.js, Fastify é a opção preferencial devido ao seu foco em alta performance, baixo overhead e arquitetura de plugins extensível e leve. Essa arquitetura facilita a modularização do código e a integração de funcionalidades como WebSockets e validação de schemas, tornando-o otimizado para aplicações em tempo real. Embora Express seja uma alternativa, Fastify apresenta vantagens em velocidade e eficiência.

Banco de Dados (PostgreSQL com Supabase/Neon e Prisma): PostgreSQL, gerenciado via Supabase (ou Neon, conforme a necessidade), é escolhido por sua robustez e escalabilidade. O Prisma atua como a camada de acesso a dados (ORM), proporcionando type safety em TypeScript, uma forma declarativa e intuitiva para modelagem de dados (schema.prisma), e um sistema robusto para migrações de banco de dados. A integração com Supabase simplifica o gerenciamento do banco de dados.

Ambiente de Desenvolvimento (Lovable): Lovable é selecionado como o ambiente de desenvolvimento por oferecer maior controle sobre a infraestrutura, estabilidade e integração contínua. Ele suporta múltiplos workspaces, deploy automatizado (CI/CD), uso de monorepos com controle avançado de versões, integração direta com Supabase, GitHub, Vercel, e ferramentas como Litestream para persistência de banco de dados. Permite também a configuração de ambientes de staging e produção separados. Credenciais de APIs externas (Twilio, Meta, Zap API, Asaas) serão armazenadas por meio de variáveis de ambiente seguras no Lovable.

Assistência com IA (Opcional): Uso opcional do Cursor para acelerar a produtividade com sugestões de código, refatoração e documentação assistida.

C. Visão Geral das Capacidades Essenciais

O sistema final deverá entregar as seguintes funcionalidades principais:

Caixa de Entrada Unificada: Visão centralizada de conversas vindas de múltiplos canais de atendimento.
CRM Nativo: Captura e gestão automática de leads a partir das conversas iniciadas.
Integração com Canais de Comunicação:
WhatsApp (via Twilio e Zap API com QR Code)
Instagram Direct e Facebook Messenger (via Meta Graph API)
Integração com Cobranças: Geração e acompanhamento de cobranças via API da Asaas.
Mensagens e Notificações em Tempo Real: Via WebSockets com Socket.IO, com uso de rooms para segmentação por conversa ou agente.
D. Implicações da Plataforma e Stack

A decisão de utilizar Lovable como ambiente de desenvolvimento proporciona flexibilidade e controle, permitindo pipelines CI/CD, uso de monorepos e integração com um ecossistema moderno. A combinação de Fastify e Prisma no backend visa alta eficiência e manutenibilidade. Fastify é otimizado para velocidade, enquanto Prisma garante interações com o banco de dados seguras em tipo e simplificadas. Contudo, a integração eficaz dessas duas ferramentas exige atenção. É crucial gerenciar o ciclo de vida do cliente Prisma dentro do contexto das requisições e plugins do Fastify. Padrões como a utilização de decoradores ou plugins do Fastify para disponibilizar uma instância singleton do Prisma são recomendados para otimizar a performance e evitar o esgotamento de conexões do banco de dados. A escolha de Lovable, em detrimento de ambientes mais limitados, mitiga preocupações de vendor lock-in e oferece um caminho mais claro para escalabilidade.

II. Análise Fundacional: Aprendendo com o Chatwoot

A. Identificação de Módulos Chave (Análise do Repositório)

Uma análise da estrutura do repositório do Chatwoot (Ruby on Rails) revela componentes principais que podem inspirar a estrutura do novo sistema:

app/controllers: Lógica para lidar com requisições HTTP (análogo aos route handlers/controllers em Fastify).
app/models: Definição das estruturas de dados (inspiração para o schema Prisma).
app/jobs: Processamento assíncrono (relevante para notificações, webhooks).
app/services: Encapsulamento da lógica de negócios.
app/listeners: Manipulação de eventos (relevante para tempo real).
app/javascript: Componentes de frontend (será mapeado para React/Vite com a estrutura modular definida).
config/routes.rb: Definição das rotas da API (análogo às rotas Fastify).
Módulos específicos de integrações.
O fluxo fundamental envolve: recebimento de mensagem via webhook, processamento, armazenamento, notificação à interface do agente via WebSockets, exibição na caixa de entrada unificada e gerenciamento de canais.

B. Estratégia de Adaptação para Stack Moderna e Lovable

A transição do Chatwoot para a stack definida (Node.js/Fastify, React/Vite, Prisma, Supabase/Neon) requer uma adaptação cuidadosa:

Backend: Mapear conceitos do Rails para Node.js/Fastify e Prisma (rotas, serviços, Prisma Client).
Frontend: Adotar a estrutura de módulos isolados com React e Vite, utilizando componentes funcionais e hooks.
Tempo Real: Implementar solução equivalente ao Action Cable usando Socket.IO integrado ao Fastify.
Banco de Dados: Adaptar modelos de dados para o schema.prisma (PostgreSQL no Supabase/Neon).
Configuração/Segredos: Utilizar variáveis de ambiente seguras no Lovable.
C. Implicações da Adaptação

Uma portabilidade direta da arquitetura do Chatwoot não é eficaz. É melhor reimplementar funcionalidades e modelos de dados usando as melhores práticas do ecossistema Node.js/Fastify e Prisma, focando na natureza assíncrona do Node.js, modularidade do Fastify e segurança de tipos do Prisma.

Dado a complexidade do Chatwoot, o desenvolvimento deve priorizar um Produto Mínimo Viável (MVP) com as funcionalidades essenciais: caixa de entrada unificada, CRM nativo básico e integrações chave (WhatsApp, Instagram, Facebook, Asaas). Funcionalidades adicionais serão planejadas para fases subsequentes. O ambiente Lovable suporta essa abordagem iterativa com seus recursos de CI/CD e ambientes de staging/produção.

III. Blueprint Arquitetural

A. Diagrama de Sistema de Alto Nível

(Descrição do Diagrama - um diagrama visual seria incluído aqui no relatório real)
O diagrama arquitetural ilustra os principais componentes e fluxos de dados do sistema:

Frontend: Aplicação React/Vite hospedada via Vercel (integrado ao Lovable), interagindo com o usuário.
Backend API: Serviço Node.js/Fastify rodando no ambiente Lovable, expondo a API RESTful e gerenciando a lógica de negócios.
Banco de Dados: Instância PostgreSQL gerenciada via Supabase (ou Neon), acessada pelo backend através do Prisma, com possível uso de Litestream para persistência contínua.
Servidor WebSocket: Integrado ao backend Fastify (usando Socket.IO), responsável pela comunicação em tempo real com o frontend.
APIs Externas: Serviços de terceiros como Twilio, Zap API, Meta (Facebook/Instagram) e Asaas.
Fluxos de Dados:
Usuário interage com o Frontend.
Frontend envia requisições API para o Backend.
Frontend estabelece conexão WebSocket com o Backend.
Backend lê/escreve no Banco de Dados via Prisma.
Backend envia/recebe dados das APIs Externas.
APIs Externas enviam notificações (webhooks) para o Backend.
Backend envia eventos em tempo real para o Frontend via WebSockets.
B. Arquitetura Frontend (React/Vite)

A arquitetura frontend será baseada na modularidade e isolamento completo dos componentes, conforme a estrutura de diretórios especificada:

Estrutura de Diretórios (apps/frontend/src/):

/src/
├── main.tsx                     # Ponto de entrada da aplicação
├── App.tsx                      # Composição geral de rotas e layout base
├── routes/                      # Arquivo de rotas por módulo
│   └── index.tsx                # Define as rotas principais (Inbox, Settings, etc.)
├── modules/                     # Cada módulo é completamente isolado
│   ├── Inbox/                   # Módulo Caixa de Entrada
│   │   ├── components/          # Componentes específicos do Inbox
│   │   │   ├── InboxPanel.tsx
│   │   │   ├── ConversationList.tsx
│   │   │   └── ConversationItem.tsx
│   │   ├── hooks/               # Hooks específicos do Inbox
│   │   │   └── useInbox.ts
│   │   ├── services/            # Chamadas API específicas do Inbox
│   │   │   └── inboxAPI.ts
│   │   ├── types/               # Tipos específicos do Inbox
│   │   │   └── inbox.types.ts
│   │   └── index.tsx            # Ponto de entrada/exportação do módulo Inbox
│   ├── Messages/                # Módulo da área de mensagens
│   │   ├── components/
│   │   │   ├── MessageBubble.tsx
│   │   │   ├── InputArea.tsx
│   │   │   └── FileUploader.tsx
│   │   ├── hooks/
│   │   │   └── useMessages.ts
│   │   ├── services/
│   │   │   └── messagesAPI.ts
│   │   ├── types/
│   │   └── index.tsx
│   ├── Contacts/
│   │   ├── components/
│   │   │   └── ContactPanel.tsx
│   │   ├── services/
│   │   ├── hooks/
│   │   └── index.tsx
│   ├── Payments/
│   │   ├── components/
│   │   │   ├── PaymentInfo.tsx
│   │   │   └── PaymentForm.tsx
│   │   ├── services/
│   │   │   └── paymentsAPI.ts
│   │   ├── hooks/
│   │   └── index.tsx
│   └── Settings/
│       ├── components/
│       └── index.tsx
├── shared/                      # Recursos compartilhados entre módulos
│   ├── ui/                     # Componentes UI globais (Botões, Modal, etc.)
│   ├── sockets/                # Configuração e lógica do cliente WebSocket (socket.io-client)
│   ├── lib/                    # Funções utilitárias globais
│   ├── config/                 # Configurações globais (tema, constantes, tokens)
│   └── store/                  # Stores Zustand ou Context API para estado global (auth, conexão)
├── styles/
│   └── tailwind.config.ts
└── index.css
Isolamento e Escalabilidade: Cada módulo (Inbox, Messages, Payments, etc.) terá seus próprios componentes, chamadas de API, hooks e tipos. Isso permite escalabilidade (possibilidade de microfrontends no futuro), facilidade de teste (unitário e de integração por módulo) e desacoplamento (alterações em um módulo não afetam outros).

Estratégia de Componentes: Dentro de cada modules/<Modulo>/components/, pode-se adotar Atomic Design ou uma estrutura similar para organizar os componentes específicos daquele módulo. Componentes reutilizáveis em toda a aplicação estarão em shared/ui/.

Gerenciamento de Estado:

Estado Local do Módulo: Gerenciado dentro de cada módulo usando useState, useReducer e hooks customizados (modules/<Modulo>/hooks/).
Estado Global: Utilizar Zustand ou Context API, localizados em shared/store/, para estados como sessão do usuário, status da conexão WebSocket, notificações globais e conversas ativas que precisam ser acessadas por múltiplos módulos.
Abordagem de UI: Utilizar TailwindCSS para estilização, configurado em styles/tailwind.config.ts. Componentes UI globais e reutilizáveis estarão em shared/ui/.

Interação com API: Serviços de API para cada módulo estarão em modules/<Modulo>/services/ (ex: inboxAPI.ts). Funções utilitárias para chamadas API podem residir em shared/lib/.

Atualizações em Tempo Real: A integração com o cliente Socket.IO será gerenciada em shared/sockets/, e os hooks e lógicas específicas de cada módulo para lidar com eventos WebSocket estarão em modules/<Modulo>/hooks/ ou modules/<Modulo>/sockets/ (se houver lógica cliente mais complexa por módulo).

C. Arquitetura Backend (Node.js/Fastify)

A arquitetura do backend seguirá uma organização modular por domínio, alinhada com as práticas de isolamento:

Estrutura de Diretórios (apps/backend/src/):

/apps/backend/
├── prisma/            # Migrations, schema.prisma e seeds
│   ├── schema.prisma
│   └── seed.ts
├── src/
│   ├── config/        # Configurações globais (env, cors, helmet)
│   ├── plugins/       # Plugins Fastify (Prisma, SocketIO, autenticação, etc.)
│   ├── modules/       # Domínios/Módulos do sistema
│   │   ├── auth/
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.service.ts
│   │   │   ├── auth.routes.ts
│   │   │   └── auth.schema.ts
│   │   ├── contacts/
│   │   ├── conversations/
│   │   ├── messages/
│   │   ├── channels/
│   │   ├── payments/
│   │   ├── webhooks/
│   │   └── adapters/  # Adapters de canais (Twilio, ZapAPI, Meta, Asaas)
│   │       ├── twilio.adapter.ts
│   │       └── meta.adapter.ts
│   ├── sockets/       # Lógica e eventos WebSocket (servidor)
│   │   └── index.ts
│   ├── services/      # Lógicas de negócio compartilhadas (se houver)
│   ├── utils/         # Utilitários e helpers globais
│   ├── index.ts       # Entry point da aplicação Fastify
│   └── server.ts      # Configuração do servidor Fastify
└── .env               # Variáveis de ambiente (gerenciadas pelo Lovable)
Modularização por Domínio: O diretório src/modules/ conterá a lógica para cada domínio principal (auth, contacts, messages, etc.). Cada módulo terá seus próprios controllers, services, rotas e schemas de validação (usando Zod).

Plugins Fastify: Localizados em src/plugins/, serão usados para encapsular funcionalidades transversais como a integração com Prisma, Socket.IO, CORS, Helmet, e autenticação JWT.

Design da API: Seguir os princípios RESTful. Definir schemas claros para requisições e respostas usando Zod, integrado com fastify-type-provider-zod.

Módulos Chave:

Auth: Gerenciamento de autenticação/autorização JWT.
ChannelAdapters: Em src/modules/adapters/, cada canal (WhatsApp, Instagram, etc.) terá um adaptador próprio, permitindo escalabilidade e manutenção isolada.
WebhookProcessor: Dentro de src/modules/webhooks/, ponto central para recebimento, validação e roteamento de webhooks.
RealtimeService/Sockets: Em src/sockets/, gerenciamento de conexões Socket.IO e difusão de eventos.
Outros Módulos: contacts, conversations, messages, payments seguirão a estrutura de controller, service, routes, schema.
Packages Compartilhados (Opcional, se usando monorepo com Turborepo):

/packages/
├── ui/                    # Componentes UI compartilhados (React + Tailwind) - se usado como biblioteca separada
└── types/                 # Tipagens compartilhadas (Zod, interfaces) entre frontend e backend
Esta estrutura (packages/) é mais relevante se um monorepo gerenciado por ferramentas como Turborepo for utilizado, conforme sugerido nas ferramentas opcionais. A estrutura shared/ dentro do frontend é suficiente para compartilhamento interno ao frontend. Tipos globais podem ser definidos em packages/types/ para consistência entre frontend e backend.

D. Camada de Tempo Real (WebSockets/Socket.IO)

Estratégia: Utilizar Socket.IO.
Integração com Fastify: Anexar o servidor Socket.IO diretamente à instância do servidor HTTP subjacente que o Fastify utiliza.
Eventos e Salas: Definir eventos claros (ex: new_message, payment_update). Usar salas do Socket.IO para segmentação (ex: por conversationId, agentId).
Autenticação: Proteger conexões WebSocket via token JWT enviado durante o handshake.
E. Camada de Dados (PostgreSQL com Supabase/Neon e Prisma)

Integração ORM: Prisma Client para todas as operações de banco de dados. Instância singleton gerenciada via plugin Fastify.
Filosofia de Schema: Definir schema em prisma/schema.prisma. Usar Prisma Migrate para migrações.
Pool de Conexões: Gerenciado pelo Prisma Client, configurado com a connection string do Supabase/Neon (armazenada como variável de ambiente segura no Lovable).
F. Implicações Arquiteturais Adicionais

Channel Adapters: Essenciais para escalabilidade e manutenção isolada da lógica de cada canal de comunicação.
Atualizações Otimistas (Optimistic UI): No frontend, fornecer feedback instantâneo ao usuário durante o envio de mensagens.
Fallbacks de Conectividade: Estratégias de reconexão automática e notificação de status via Socket.IO no frontend.
Abordagem de Jobs Assíncronos para Webhooks: Para aumentar a resiliência, considerar processar webhooks de forma desacoplada (ex: usando uma fila simples ou um serviço como BullMQ) para evitar perda de dados em picos de carga.
IV. Design do Schema do Banco de Dados (PostgreSQL com Prisma)

(Esta seção permanece conceitualmente a mesma do documento original, com os modelos User, Contact, Channel, Conversation, Message, AsaasCustomer, AsaasCharge. As alterações principais seriam garantir que os nomes dos campos e relacionamentos estejam consistentes com o que foi definido. A configuração do schema.prisma e os exemplos de modelos são válidos. A DATABASE_URL será gerenciada pelo Lovable.)

Configuração do schema.prisma:
Snippet de código

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // Obtido das variáveis de ambiente do Lovable
}
Modelos de Dados Principais: (Conforme detalhado no documento original: User, Contact, Channel, Conversation, Message, AsaasCustomer, AsaasCharge, com seus respectivos campos e enums).
Relacionamentos e Restrições: Conforme definido, com atenção a índices em chaves estrangeiras e campos de filtro.
Implicações do Design do Schema: A modelagem do remetente em Message (com senderType) e o armazenamento seguro de nomes de segredos (e não os valores) em Channel continuam sendo pontos importantes.
V. Estratégia de Desenvolvimento Frontend (React/Vite)

A. Setup e Ferramentas

Inicialização: npm create vite@latest omnichannel-app -- --template react-ts (ou pnpm). A estrutura de diretórios será criada manualmente conforme o blueprint.
Dependências: react-router-dom, axios (ou Workspace), socket.io-client, tailwindcss, zustand (ou usar Context API), zod (para validação de formulários, opcional).
Configuração: TailwindCSS (styles/tailwind.config.ts), vite.config.ts.
B. Detalhamento dos Componentes Chave da UI (Exemplos por Módulo)

Módulo Inbox (src/modules/Inbox/components/):
InboxPanel.tsx: Painel lateral com ConversationList.
ConversationList.tsx: Lista de ConversationItem.
ConversationItem.tsx: Item resumido da conversa.
Módulo Messages (src/modules/Messages/components/):
MessageList.tsx (ou similar, para exibir a sequência de MessageBubble).
MessageBubble.tsx: Exibe uma mensagem individual.
InputArea.tsx: Campo para digitar e enviar mensagens.
FileUploader.tsx: Para envio de arquivos.
Módulo Contacts (src/modules/Contacts/components/):
ContactPanel.tsx: Painel de informações do contato ativo.
ContactForm.tsx: Para editar dados do contato.
Módulo Payments (src/modules/Payments/components/):
PaymentInfo.tsx: Detalhes da cobrança.
PaymentForm.tsx: Formulário para criar cobrança.
Recursos Compartilhados (src/shared/ui/):
Button.tsx, Modal.tsx, Avatar.tsx, Input.tsx, etc.
C. Abordagem de Estilização (TailwindCSS)

Utilizar classes utilitárias diretamente nos componentes. Definir sistema de design (cores, tipografia) em tailwind.config.js. Garantir responsividade.