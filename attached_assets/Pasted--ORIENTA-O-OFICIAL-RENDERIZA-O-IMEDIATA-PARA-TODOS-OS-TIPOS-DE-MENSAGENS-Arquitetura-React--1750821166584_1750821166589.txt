âœ… ORIENTAÃ‡ÃƒO OFICIAL â€“ RENDERIZAÃ‡ÃƒO IMEDIATA PARA TODOS OS TIPOS DE MENSAGENS
ğŸ”§ Arquitetura: React Query como fonte Ãºnica de verdade (Zustand removido)
Agora que o EduChat utiliza exclusivamente o React Query (TanStack Query) como responsÃ¡vel pelo estado das mensagens, o envio e a renderizaÃ§Ã£o imediata devem seguir uma lÃ³gica padronizada para todos os tipos de mensagens.

âœ… O QUE DEVE SER FEITO
1ï¸âƒ£ Ao enviar qualquer mensagem (texto, Ã¡udio, mÃ­dia, documento, etc.):
A mutaÃ§Ã£o do React Query (useMutation) deve ser utilizada para enviar os dados via Z-API.

No onSuccess, o resultado da API (mensagem recÃ©m-criada) deve ser adicionado diretamente ao cache do React Query, via queryClient.setQueryData(...).

A interface deve reagir automaticamente e renderizar essa nova mensagem.

2ï¸âƒ£ O WebSocket tem funÃ§Ã£o secundÃ¡ria:
Deve apenas atualizar o cache do React Query para mensagens recebidas de outros usuÃ¡rios ou dispositivos.

Jamais depender do WebSocket para mostrar a mensagem que o prÃ³prio usuÃ¡rio acabou de enviar.

TambÃ©m deve evitar atualizar redundÃ¢ncias que jÃ¡ foram tratadas localmente.

3ï¸âƒ£ O componente de interface (MessageBubble ou equivalente):
Deve ser capaz de renderizar corretamente todos os tipos de mensagens, com base em uma propriedade type, como:

text

audio

image

file

video

Cada tipo deve ter sua apresentaÃ§Ã£o visual bem definida e padronizada.

ğŸ§  EXEMPLO DO FLUXO PADRÃƒO NO useSendMessage.ts
ts
Copiar
Editar
mutationFn: async (payload) => {
  const response = await api.sendMessage(payload); // Funciona para texto, mÃ­dia, etc.
  return response.data; // Mensagem completa retornada pela API
},
onSuccess: (newMessage) => {
  queryClient.setQueryData(
    [`/api/conversations/${newMessage.conversationId}/messages`],
    (old: Message[] = []) => [...old, newMessage]
  );
}
ğŸŸ¥ O QUE DEVE SER EVITADO
âŒ NÃ£o esperar o WebSocket ou qualquer evento externo para mostrar uma mensagem que acabou de ser enviada.

âŒ NÃ£o usar polling ou refetch apÃ³s o envio como garantia â€” se o cache estiver correto, a UI atualizarÃ¡ naturalmente.

âŒ NÃ£o duplicar lÃ³gica entre hooks como useMessages, useWebSocket, ou reprocessar mensagens que jÃ¡ estÃ£o no cache.

ğŸ¯ META DO TIME
A sensaÃ§Ã£o de instantaneidade no envio de qualquer tipo de mensagem Ã© essencial para uma boa experiÃªncia de usuÃ¡rio.
Independentemente do tipo de mensagem enviada, ela deve aparecer imediatamente na conversa, sem atrasos ou necessidade de sincronizaÃ§Ãµes extras.

