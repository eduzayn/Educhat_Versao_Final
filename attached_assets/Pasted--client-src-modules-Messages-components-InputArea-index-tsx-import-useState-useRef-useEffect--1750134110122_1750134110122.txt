// client/src/modules/Messages/components/InputArea/index.tsx
import { useState, useRef, useEffect } from "react";
import { Mic, Send } from "lucide-react";
import { Button } from "@/shared/ui/button";
import { Textarea } from "@/shared/ui/textarea";
import { useSendMessage } from "@/shared/lib/hooks/useMessages";
import { useQuickReplies, useIncrementQuickReplyUsage } from "@/shared/lib/hooks/useQuickReplies";
import { useChatStore } from "@/shared/store/chatStore";
import { useToast } from "@/shared/lib/hooks/use-toast";
import { cn } from "@/lib/utils";
import type { QuickReply } from "@shared/schema";

import { QuickReplyDropdown } from "./QuickReplyDropdown";
import { QuickReplyChips } from "./QuickReplyChips";

export function InputArea() {
  // Estados principais
  const [message, setMessage] = useState("");
  const [showQuickReplies, setShowQuickReplies] = useState(false);
  const [quickReplyFilter, setQuickReplyFilter] = useState("");
  const [selectedQuickReplyIndex, setSelectedQuickReplyIndex] = useState(0);

  // Refs
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Hooks
  const { activeConversation } = useChatStore();
  const sendMessageMutation = useSendMessage();
  const { toast } = useToast();
  const incrementUsageMutation = useIncrementQuickReplyUsage();

  // Buscar respostas rápidas
  const { data: quickReplies = [] } = useQuickReplies();

  // Filtrar respostas rápidas baseado no input
  const filteredQuickReplies = quickReplies.filter(
    (reply) =>
      reply.title.toLowerCase().includes(quickReplyFilter.toLowerCase()) ||
      (reply.description?.toLowerCase().includes(quickReplyFilter.toLowerCase()) ?? false) ||
      (reply.content?.toLowerCase().includes(quickReplyFilter.toLowerCase()) ?? false),
  );

  // Auto-resize textarea
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
      textareaRef.current.style.height =
        Math.min(textareaRef.current.scrollHeight, 120) + "px";
    }
  }, [message]);

  // Handler de digitação com detecção de "/"
  const handleTyping = (value: string) => {
    setMessage(value);

    // Detectar "/" para ativar respostas rápidas
    const lastSlashIndex = value.lastIndexOf("/");
    if (lastSlashIndex !== -1 && lastSlashIndex === value.length - 1) {
      setShowQuickReplies(true);
      setQuickReplyFilter("");
      setSelectedQuickReplyIndex(0);
    } else if (
      lastSlashIndex !== -1 &&
      value.substring(lastSlashIndex + 1).indexOf(" ") === -1
    ) {
      setShowQuickReplies(true);
      setQuickReplyFilter(value.substring(lastSlashIndex + 1));
      setSelectedQuickReplyIndex(0);
    } else {
      setShowQuickReplies(false);
      setQuickReplyFilter("");
    }
  };

  // Handler de envio de mensagem
  const handleSendMessage = async () => {
    if (!message.trim() || !activeConversation) return;

    const messageContent = message.trim();
    setMessage("");

    try {
      await sendMessageMutation.mutateAsync({
        conversationId: activeConversation.id,
        message: {
          content: messageContent,
          isFromContact: false,
          messageType: "text",
        },
        contact: activeConversation.contact,
      });
    } catch (error) {
      toast({
        title: "Erro",
        description: "Falha ao enviar mensagem. Tente novamente.",
        variant: "destructive",
      });
    }
  };

  // Handler de teclas para navegação
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (showQuickReplies && filteredQuickReplies.length > 0) {
      if (e.key === "ArrowDown") {
        e.preventDefault();
        setSelectedQuickReplyIndex((prev) =>
          prev < filteredQuickReplies.length - 1 ? prev + 1 : 0,
        );
        return;
      }
      if (e.key === "ArrowUp") {
        e.preventDefault();
        setSelectedQuickReplyIndex((prev) =>
          prev > 0 ? prev - 1 : filteredQuickReplies.length - 1,
        );
        return;
      }
      if (e.key === "Tab") {
        e.preventDefault();
        selectQuickReply(filteredQuickReplies[selectedQuickReplyIndex]);
        return;
      }
      if (e.key === "Escape") {
        e.preventDefault();
        setShowQuickReplies(false);
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      if (showQuickReplies && filteredQuickReplies.length > 0) {
        selectQuickReply(filteredQuickReplies[selectedQuickReplyIndex]);
      } else {
        handleSendMessage();
      }
    }
  };

  // Selecionar resposta rápida
  const selectQuickReply = (quickReply: QuickReply) => {
    const lastSlashIndex = message.lastIndexOf("/");
    const beforeSlash = message.substring(0, lastSlashIndex);

    let content = "";
    if (quickReply.type === "text") {
      content = quickReply.content || "";
    } else if (quickReply.type === "audio" && quickReply.fileUrl) {
      handleSendQuickReplyMedia(quickReply, "audio");
      return;
    } else if (quickReply.type === "image" && quickReply.fileUrl) {
      handleSendQuickReplyMedia(quickReply, "image");
      return;
    } else if (quickReply.type === "video" && quickReply.fileUrl) {
      handleSendQuickReplyMedia(quickReply, "video");
      return;
    }

    setMessage(beforeSlash + content);
    setShowQuickReplies(false);
    textareaRef.current?.focus();

    // Incrementar contador de uso
    incrementUsageMutation.mutate(quickReply.id);
  };

  // Enviar mídia de resposta rápida
  const handleSendQuickReplyMedia = async (quickReply: QuickReply, type: string) => {
    if (!activeConversation || !quickReply.fileUrl) return;

    try {
      await sendMessageMutation.mutateAsync({
        conversationId: activeConversation.id,
        message: {
          content: quickReply.fileUrl,
          isFromContact: false,
          messageType: type as any,
        },
        contact: activeConversation.contact,
      });
      setMessage("");
      setShowQuickReplies(false);
      
      // Incrementar contador de uso
      incrementUsageMutation.mutate(quickReply.id);
    } catch (error) {
      toast({
        title: "Erro",
        description: `Falha ao enviar ${type}. Tente novamente.`,
        variant: "destructive",
      });
    }
  };

  // Inserir resposta rápida simples
  const insertQuickReply = (reply: string) => {
    setMessage(reply);
    textareaRef.current?.focus();
  };

  if (!activeConversation) {
    return null;
  }

  return (
    <div className="bg-white border-t border-gray-200 p-4">
      <div className="flex items-end space-x-3">
        <div className="flex-1 relative">
          <Textarea
            ref={textareaRef}
            placeholder="Digite sua mensagem... (use / para respostas rápidas)"
            value={message}
            onChange={(e) => handleTyping(e.target.value)}
            onKeyPress={handleKeyPress}
            className="min-h-[48px] max-h-[140px] resize-none pr-20 border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent text-base"
            rows={1}
          />

          <QuickReplyDropdown
            visible={showQuickReplies}
            filteredReplies={filteredQuickReplies}
            onSelect={selectQuickReply}
            selectedIndex={selectedQuickReplyIndex}
          />
        </div>

        <Button
          onClick={handleSendMessage}
          disabled={!message.trim() || sendMessageMutation.isPending}
          className={cn(
            "bg-blue-600 hover:bg-blue-700 text-white p-3.5 rounded-xl transition-colors",
            sendMessageMutation.isPending && "opacity-50 cursor-not-allowed",
          )}
        >
          {sendMessageMutation.isPending ? (
            <div className="w-5.5 h-5.5 animate-spin rounded-full border-2 border-white border-t-transparent" />
          ) : (
            <Send className="w-5.5 h-5.5" />
          )}
        </Button>
      </div>

      {/* Chips de respostas rápidas */}
      <QuickReplyChips onSelect={insertQuickReply} />
    </div>
  );
}