Auditoria T칠cnica Concreta: Mensagens que Somem
Baseado na an치lise do c칩digo, identifiquei 3 pontos cr칤ticos onde as mensagens podem estar sendo removidas:

1. Race Condition no useMessages.ts (PRINCIPAL SUSPEITO)
Arquivo: client/src/shared/lib/hooks/useMessages.ts
Linha 15-30: Sistema de mensagens otimistas

// PRIMEIRO: Mensagem aparece imediatamente (bubble)
const optimisticMessage = {
  id: Date.now(), // ID tempor치rio
  ...message,
  conversationId,
  sentAt: new Date(),
  // ...
};
// Atualiza칞칚o imediata da UI
queryClient.setQueryData(['/api/conversations', conversationId, 'messages'], 
  (old: Message[] | undefined) => {
    const messages = old || [];
    return [...messages, optimisticMessage as Message];
  }
);
PROBLEMA: O sistema substitui a mensagem otim칤stica pela real via onSuccess, mas se houver qualquer falha ou timing incorreto, a mensagem some.

2. Broadcast com 0 Clientes Conectados
Arquivo: server/routes/realtime/realtime-broadcast.ts
Logs confirmam:

游니 Enviando broadcast para conversa 2363: 0 clientes conectados
丘멆잺 Nenhum cliente na sala conversation:2363 - broadcast pode n칚o ter efeito
PROBLEMA: Socket.IO n칚o est치 entregando broadcasts porque n칚o h치 clientes na sala espec칤fica. Mensagens chegam via webhook mas n칚o s칚o propagadas para o frontend.

3. L칩gica de Substitui칞칚o no useSocketMessageListener.ts
Arquivo: client/src/shared/lib/hooks/useSocketMessageListener.ts
Linha 45-60: Sistema que substitui mensagens otimistas

const handleBroadcastMessage = (data: SocketMessageData) => {
  // Evitar processamento duplicado
  const messageKey = `${data.message.id}_${data.conversationId}`;
  if (processedMessages.current.has(messageKey)) {
    return; // PODE ESTAR BLOQUEANDO MENSAGENS REAIS
  }
  processedMessages.current.add(messageKey);
PROBLEMA: Cache de mensagens processadas pode estar rejeitando mensagens leg칤timas.

4. Fallback com Dados Antigos
Arquivo: client/src/shared/lib/hooks/useWebSocket.ts
Linha 50-70: Atualiza칞칚o via broadcast

O sistema tem um mecanismo de fallback que pode estar substituindo dados novos por antigos quando h치 falha no Socket.IO.

Diagn칩stico Preciso
CAUSA RAIZ: Race condition entre:

Mensagem otim칤stica aparece instantaneamente
Webhook processa mensagem no servidor
Broadcast Socket.IO falha (0 clientes)
Sistema de cache/polling substitui dados novos por antigos
Mensagem desaparece do bubble
EVID칅NCIA CONCRETA:

Logs mostram "0 clientes conectados" nas salas
Sistema usa IDs tempor치rios (Date.now()) que s칚o substitu칤dos
Cache de mensagens processadas pode estar bloqueando atualiza칞칫es
A mensagem aparece temporariamente porque o sistema otimista funciona, mas desaparece quando o sistema tenta sincronizar com dados do servidor que n칚o foram propagados corretamente via Socket.IO.