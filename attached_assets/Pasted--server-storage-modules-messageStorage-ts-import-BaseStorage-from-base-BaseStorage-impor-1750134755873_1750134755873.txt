// server/storage/modules/messageStorage.ts
import { BaseStorage } from "../base/BaseStorage";
import { messages, type Message, type InsertMessage } from "@shared/schema";
import { eq, desc, and, or } from "drizzle-orm";

export class MessageStorage extends BaseStorage {
  
  // Buscar mensagens de uma conversa (incluindo notas internas)
  async getMessages(conversationId: number, limit = 25, offset = 0): Promise<Message[]> {
    return this.db.select().from(messages)
      .where(and(
        eq(messages.conversationId, conversationId),
        eq(messages.isDeleted, false)
      ))
      .orderBy(desc(messages.sentAt))
      .limit(limit)
      .offset(offset);
  }

  // Buscar apenas notas internas de uma conversa
  async getInternalNotes(conversationId: number): Promise<Message[]> {
    return this.db.select().from(messages)
      .where(and(
        eq(messages.conversationId, conversationId),
        eq(messages.isInternalNote, true),
        eq(messages.isDeleted, false)
      ))
      .orderBy(desc(messages.sentAt));
  }

  // Criar nota interna
  async createInternalNote(data: {
    conversationId: number;
    content: string;
    authorId: number;
    authorName: string;
    noteType?: string;
    notePriority?: string;
    noteTags?: string[];
    isPrivate?: boolean;
  }): Promise<Message> {
    const noteData: InsertMessage = {
      conversationId: data.conversationId,
      content: data.content,
      isFromContact: false,
      isInternalNote: true,
      authorId: data.authorId,
      authorName: data.authorName,
      messageType: 'text',
      noteType: data.noteType || 'general',
      notePriority: data.notePriority || 'normal',
      noteTags: data.noteTags || [],
      isPrivate: data.isPrivate || false,
      sentAt: new Date()
    };

    return this.createMessage(noteData);
  }

  // Criar mensagem normal
  async createMessage(messageData: InsertMessage): Promise<Message> {
    const [newMessage] = await this.db.insert(messages).values(messageData).returning();
    return newMessage;
  }

  // Atualizar mensagem
  async updateMessage(id: number, messageData: Partial<InsertMessage>): Promise<Message> {
    const [updated] = await this.db.update(messages)
      .set(messageData)
      .where(eq(messages.id, id))
      .returning();
    return updated;
  }

  // Marcar mensagem como deletada
  async markMessageAsDeleted(id: number, deletedBy?: number): Promise<void> {
    await this.db.update(messages)
      .set({ 
        isDeleted: true, 
        deletedAt: new Date(),
        deletedBy: deletedBy || null
      })
      .where(eq(messages.id, id));
  }

  // Buscar mensagem por ID
  async getMessage(id: number): Promise<Message | undefined> {
    const [message] = await this.db.select().from(messages).where(eq(messages.id, id));
    return message;
  }

  // Buscar mensagens por tipo
  async getMessagesByType(conversationId: number, type: string): Promise<Message[]> {
    return this.db.select().from(messages)
      .where(and(
        eq(messages.conversationId, conversationId),
        eq(messages.messageType, type),
        eq(messages.isDeleted, false)
      ))
      .orderBy(desc(messages.sentAt));
  }

  // Buscar notas internas por prioridade
  async getInternalNotesByPriority(conversationId: number, priority: string): Promise<Message[]> {
    return this.db.select().from(messages)
      .where(and(
        eq(messages.conversationId, conversationId),
        eq(messages.isInternalNote, true),
        eq(messages.notePriority, priority),
        eq(messages.isDeleted, false)
      ))
      .orderBy(desc(messages.sentAt));
  }

  // Buscar notas internas por tags
  async getInternalNotesByTags(conversationId: number, tags: string[]): Promise<Message[]> {
    return this.db.select().from(messages)
      .where(and(
        eq(messages.conversationId, conversationId),
        eq(messages.isInternalNote, true),
        or(...tags.map(tag => messages.noteTags.contains([tag]))),
        eq(messages.isDeleted, false)
      ))
      .orderBy(desc(messages.sentAt));
  }
}